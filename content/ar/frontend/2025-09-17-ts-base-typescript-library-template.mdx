---
title: "تقديم ts-base: قالب حديث لمكتبات TypeScript"
description: "ابنِ باستخدام tsdown وVitest وrelease-please وBiome."
date: "2025-09-17T12:30:00-06:00"
tags: [frontend, open-source]
---

قبل ثماني سنوات، أطلقت أول مكتبة TypeScript مفتوحة المصدر — [Squirrelly](https://github.com/squirrellyjs/squirrelly) — وكانت تتكوّن من ملفين فقط: `package.json` و`index.js`. قبل خمس سنوات، أطلقت [Eta](https://github.com/bgub/eta) مع مزيد من الميزات، بما في ذلك الاختبارات، وأدوات الفحص (linting)، والتجميع (bundling)، وCI/CD.

كنت أظن أن ذلك إعداد تطوير متينًا، لكن الأوقات تتغير ونظام JavaScript البيئي يتحرك بسرعة. ظهرت أدوات جديدة، وتطورت أفضل الممارسات، وصارت عملية نشر حزمة npm بصورة صحيحة أسهل — ومع ذلك — أكثر إرباكًا في الوقت نفسه.

انظر فقط إلى تطوّر الحقل "exports" في `package.json` إن أردت صداعًا. أو حاول اكتشاف المزيج المناسب من إعدادات TypeScript، وأدوات التجميع (bundlers)، وتدفقات عمل CI لنشر مكتبة تعمل بسلاسة عبر Node وDeno وBun والمتصفحات. من المدهش مدى صعوبة إتقان ذلك.

لهذا أنشأت [**ts-base**](https://github.com/bgub/ts-base) — قالبًا حديثًا لبدء تطوير مكتبات TypeScript يتكفّل بكل هذا التعقيد عنك. إنه واضح التوجّه، مجرّب ميدانيًا، ومصمّم ليعمل مباشرة فور الاستخدام مع كل بيئات تشغيل JavaScript الرئيسية.

## ما هي ts-base؟

ts-base قالب لمكتبة TypeScript يتبنّى الأدوات الحديثة وتدفّقات العمل المؤتمتة. بدلًا من البدء من الصفر أو نسخ قوالب قديمة، ستحصل على بيئة تطوير متكاملة تتضمن التحقق البرمجي، والاختبارات، والبناء، والإصدار، والنشر — كلها مُعدّة مسبقًا وجاهزة للاستخدام.

تم بناء القالب حول ثلاثة مبادئ أساسية:

- **تعدد بيئات التشغيل أولًا**: يعمل بسلاسة عبر Node وDeno وBun والمتصفحات
- **الأتمتة قبل التهيئة**: إعداد أدنى ممكن مع أتمتة قصوى
- **أدوات حديثة**: ESM فقط، أحدث TypeScript، وتبعيات مختارة بعناية

## بنية متعددة البيئات التشغيلية

يكمن جوهر ts-base في تصميمه المستقل عن بيئة التشغيل. بدلًا من محاولة جعل ملف واحد يعمل في كل مكان (وما يرافق ذلك من صداع في التوافقية)، يعتمد القالب على فصلٍ واضح:

```typescript
// src/internal.ts - المنطق الأساسي، بدون واجهات برمجة تطبيقات خاصة بوقت التشغيل
export function add(a: number, b: number): number {
  return a + b;
}

export function greet(name: string, options = {}): string {
  const base = `مرحباً، ${name}`;
  return options.shout ? `${base.toUpperCase()}!` : `${base}.`;
}
```

```typescript
// src/index.ts - محول Node/Bun
export { add, greet } from "./internal";
import { randomBytes } from "node:crypto";

export function getSecureRandomId(): string {
  const timePart = Date.now().toString(36);
  const bytes = randomBytes(12).toString("base64url");
  return `${timePart}-${bytes}`;
}
```

```typescript
// src/browser.ts - محول المتصفح
export { add, greet } from "./internal";

export function getSecureRandomId(): string {
  const timePart = Date.now().toString(36);
  const array = new Uint8Array(12);
  crypto.getRandomValues(array);
  const rand = btoa(String.fromCharCode(...array))
    .replaceAll("+", "-")
    .replaceAll("/", "_")
    .replaceAll("=", "");
  return `${timePart}-${rand}`;
}
```

يمنحك هذا واردات نظيفة لكل بيئة تشغيل:

```typescript
// Node/Bun
import { add, getSecureRandomId } from "@your-package/ts-base";

// المتصفح (عبر أداة التجميع)
import { add, getSecureRandomId } from "@your-package/ts-base/browser";

// Deno (استيراد TypeScript مباشر)
import {
  add,
  greet,
} from "https://jsr.io/@bgub/ts-base/<version>/src/index.ts";
```

يستخدم نظام البناء [tsdown](https://tsdown.dev/) لإنشاء حزمتين مُحسَّنتين: واحدة لبيئات Node وأخرى مصغّرة مخصّصة للمتصفحات، وكلتاهما مرفقتان بخرائط المصدر.


## تجربة المطوّر

يوحّد ts-base أدواتك حول عدد قليل من الخيارات الممتازة:

**Biome** يحلّ محلّ كلٍ من ESLint وPrettier بأداة واحدة سريعة. لا مزيد من تعارضات الإعدادات أو عدم توافق الملحقات — فقط تنسيق وفحص ثابتان يعملان مباشرة دون إعداد إضافي.

**Vitest** يوفّر اختبارات سريعة جدًا مع تقارير تغطية مدمجة وعَتبات قابلة للتخصيص. تُشغَّل الاختبارات بالتوازي، وتدعم TypeScript بشكلٍ أصيل، وتتضمن ميزات مفيدة مثل المحاكاة (mocking) واللقطات (snapshots).

**Size Limit** يراقب حجم الحزمة تلقائيًا. يعمل ضمن CI ويضيف تعليقات على طلبات السحب عندما قد تزيد تغييراتك من حجم الحزمة، مما يساعدك على كشف التضخم قبل الإطلاق.

تم تحسين إعدادات TypeScript لمجمّعات حديثة بخيارات مثل `moduleResolution: "bundler"` و`allowImportingTsExtensions: true` التي تعمل بشكل رائع مع أدوات مثل Vite وRollup وesbuild.

## خط أنابيب CI/CD مؤتمت

إحدى أكبر نقاط قوة ts-base هي إعداد CI/CD المتكامل. كل ما يخص جودة الشفرة والنشر مؤتمت:

**بوابات الجودة**: كل Pull Request يشغّل الفحص بأسلوب lint، والتحقق من الأنواع، والاختبارات، والتقارير الخاصة بالتغطية. يرفع نظام CI نتائج التغطية إلى Codecov ويعلّق على الـPR بتقارير تأثير الحجم.

![Screenshot of CI/CD run](/blog-images/ci-run-screenshot.png)

**إدارة الإصدارات**: بدلًا من تهيئات semantic-release المعقدة، يستخدم ts-base أداة Release Please من Google. عند وصول الـcommits إلى فرع main، يفتح Release Please تلقائيًا “Release PR” يحدّث أرقام الإصدارات، ويولّد سجلّات التغييرات، وينشئ وسوم الإطلاق.

**النشر الآلي**: عند دمج الـRelease PR، تقوم GitHub Actions تلقائيًا ببناء حزمتك ونشرها إلى كلٍّ من npm وJSR مع إثبات منشأ OIDC كامل وإقرار أمني.

**Conventional Commits**: تُفحَص عناوين الـPR تلقائيًا للتقيد بتنسيق conventional commits، ما يضمن توليدًا متسقًا لسجلّ التغييرات.

## لماذا ينجح هذا النهج بشكل أفضل

معظم قوالب مكتبات TypeScript التي رأيتها إما بسيطة أكثر من اللازم (تترك لك مهمة إعداد CI، والنشر، ودعم تشغيل متعدد البيئات) أو معقدة بشكل مفرط مع عشرات الاعتمادات. لقد رأيت قوالب تتضمن حزمًا مثل `@commitlint/cli` و`@commitlint/config-conventional` و`@semantic-release/changelog` و`@semantic-release/git` و`@semantic-release/github` و`@semantic-release/npm` وغيرها، فقط من أجل النشر عبر CI!

يتبع ts-base نهجًا مختلفًا مع 8 اعتمادات تطوير فقط بالمجمل. باختيار Release Please بدلًا من semantic-release، وBiome بدلًا من ESLint+Prettier، وVitest بدلًا من Jest، تحصل على مخطط اعتماد أبسط، أسهل في الصيانة، وأقل عرضة للأعطال.

تعني فلسفة الأتمتة إعدادًا أقل ونقاط فشل أقل. يتولى Release Please رفع رقم الإصدار، وتوليد سجلّ التغييرات، وإنشاء الإصدارات ضمن أداة واحدة. وتتولّى مهام GitHub Actions كل ما تبقّى.

## سحر Release Please

![Screenshot of release-please PR](/blog-images/release-please-pr.png)

تستحق Release Please اهتمامًا خاصًا لأنها تغيّر طريقة تفكيرك في الإصدارات. بدلًا من ترقية الأرقام يدويًا أو إعداد خطوط نشر معقّدة لـ semantic-release، تعمل Release Please كالتالي:

1. تدمج الالتزامات إلى `main` باستخدام رسائل الالتزامات المتوافقة مع Conventional Commits
2. تفتح/تحدّث Release Please تلقائيًا "طلب إصدار" (Release PR) يتضمن ترقية النسخة وإضافات إلى سجل التغييرات (changelog)
3. عندما تكون جاهزًا للإصدار، يكفي أن تدمج طلب الإصدار
4. تنشر GitHub Actions تلقائيًا إلى npm وJSR

يدعم النظام الإصدارات المسبقة أيضًا. إذا أصدرت نسخة alpha أو beta، فسيجري نشرها تلقائيًا تحت الوسم "next" على npm. يمكنك تجاوز ترقية الرقم باستخدام `Release-As: 2.0.0` ضمن رسالة الالتزام، كما يمكنك الحفاظ على عدة فروع للإصدارات (مثل `2.x` و`3.x`) يحصل كلٌّ منها على طلب إصدار خاص به.

## البدء

إعداد ts-base بسيط:

1. **الاستنساخ والتخصيص**: استنسخ المستودع، واحذف مجلد `.git`، وحدّث ملفات `package.json` و`jsr.json` و`.release-please-manifest.json` بتفاصيل حزمتك.

2. **حجز حزمتك**: اضبط الإصدار إلى `0.0.0` في جميع ملفات الإعداد، ثم شغّل `npm publish` محليًا لحجز اسم حزمتك على npm.

3. **تهيئة النشر**: في npm، اضبط حزمتك لتتطلب المصادقة الثنائية 2FA للتفويض فقط (وليس للنشر)، ثم أضف سير عمل GitHub لديك كناشر موثوق. على JSR، أنشئ حزمتك وأضف المستودع كمصدر موثوق.

![لقطة شاشة لإعدادات نشر npm](/blog-images/npm-trusted-publisher.png)

4. **إعداد GitHub**: ادفع إلى GitHub، أضف `CODECOV_TOKEN` كسرّ للمستودع، وفعّل قواعد حماية الفروع.

5. **ابدأ التطوير**: أضف الشفرة إلى `src/`، اكتب اختبارات، وادفع الالتزامات. سيتولى Release Please الباقي.

أوصي بتهيئة GitHub للسماح بالدمج باستخدام squash فقط وباستخدام "عنوان طلب السحب وتفاصيل الالتزام" كرسالة الالتزام الافتراضية. هذا يحافظ على نظافة سجل الالتزامات ويضمن الالتزام بـ conventional commits.

## أفضل الممارسات والنصائح

**إعدادات المستودع**: فعّل حماية Branch على `main` مع فحوصات الحالة المطلوبة. عطّل عمليات الدمج (merge commits) للحفاظ على سجل تاريخي خطي.

**نقاط الدخول**: استخدم التصدير الرئيسي (`@your-package`) لـ Node/Bun، وتصدير المتصفح (`@your-package/browser`) لشيفرة المتصفح المجمّعة، واستيرادات TypeScript المباشرة لـ Deno.

**التخصيص**: إذا لم تكن بحاجة إلى إصدارات منفصلة لـ Node/المتصفح، فاحذف الإعدادات غير المستخدمة. القالب مصمّم ليُقلَّص وفق احتياجاتك المحددة.

**استراتيجية الاختبار**: يتضمن القالب أمثلة لاختبار الشيفرة المشتركة والخاصة بكل منصة، بما في ذلك محاكاة واجهات برمجة تطبيقات المتصفح في بيئة اختبار Node.

## ختامًا

لا ينبغي أن يتطلب نشر مكتبة TypeScript شهادة دكتوراه في تهيئة الأدوات. يمنحك ts-base أساسًا حديثًا برؤية واضحة يتولى التعقيدات لتتمكن من التركيز على بناء برمجيات رائعة.

يجسّد هذا القالب خلاصة ثماني سنوات من الدروس المستفادة من صيانة مشاريع مفتوحة المصدر. هل أنت مستعد لتجربته؟ اطّلع على [مستودع ts-base](https://github.com/bgub/ts-base) وابدأ بناء مكتبتك التالية.