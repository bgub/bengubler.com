---
title: "مقدمة إلى helm"
description: "إطار عمل TypeScript قوي الأنواع لوكلاء الذكاء الاصطناعي. استبدِل عشرات الأدوات بأداتين فقط — البحث والتنفيذ — واعزل الشيفرة التي تولّدها نماذج اللغة الكبيرة داخل صندوق حماية مع أذونات دقيقة."
date: "2026-02-25"
tags: [ml/ai, open-source, frontend]
---

# تقديم helm

helm هو إطار عمل TypeScript مضبوط الأنواع لوكلاء الذكاء الاصطناعي. بدلًا من تشغيل أوامر خارجية وتحليل سلاسل نصية، يستدعي الوكلاء دوالًّا مضبوطَة الأنواع بمدخلات ومخرجات مُنظَّمة:

```ts
import { createHelm, git, fs, grep } from "@bgub/helm";

const agent = createHelm({
  permissions: {
    "fs.read": "allow",
    "fs.write": "ask",
    "fs.remove": "deny",
    "git.status": "allow",
    "git.*": "ask",
  },
  onPermissionRequest: async (operation, args) => {
    return confirm(`Allow ${operation}?`);
  },
})
  .use(fs())
  .use(git())
  .use(grep());

const { staged, unstaged, branch } = await agent.git.status();
const { content } = await agent.fs.read("./package.json");
```

تسجّل &quot;skills&quot; — مجموعات من العمليات ذات الصلة — باستخدام نمط الـ builder. يستنتج TypeScript النوع الكامل في كل خطوة. لكل عملية مستوى أذونات: `allow` (تُنفَّذ فورًا)، `ask` (تتوقّف لطلب الموافقة)، أو `deny` (ترمي `PermissionDeniedError`). تُحسَم الأذونات بحسب أولوية المطابقة: مطابقة تامة → wildcard → الإعداد الافتراضي لمؤلف الـ skill → الإعداد الافتراضي العام.

توفر helm skills مدمجة للمهام التي ينفذها الـ agents كل يوم: `fs`، `git`، `grep`، `edit`، `shell`، `http`. يمكنك تعريف skills مخصّصة، وتحصل تلقائيًا على الأنواع، والبحث، والأذونات مجانًا.


## العرض التوضيحي

أنشأتُ روبوت دردشة لا يملك الوكيل فيه سوى أداتين فقط: `search` و `execute`.

تُجري `search` بحثًا عن الكلمات المفتاحية عبر جميع عمليات helm المسجَّلة — يستدعيها الوكيل لمعرفة ما هو المتاح وتعلُّم تواقيع الدوال:

```ts
agent.search("file read");
// → [{ qualifiedName: "fs.read",
//      description: "قراءة ملف وإرجاع محتواه كسلسلة نصية",
//      signature: "(path: string) => Promise<{ content: string }>", ... }]
```

تستقبل `execute` أي كود JavaScript وتنفّذه عبر واجهة برمجة تطبيقات عامل Helm. يكتب نموذج الـLLM كودًا مثل:

```js
const { staged, unstaged, branch } = await agent.git.status();
return { branch, staged: staged.length, unstaged: unstaged.length };
```

أداتان متاحتان في السياق، بغض النظر عن عدد المهارات المسجَّلة. يحدد الوكيل ما يحتاج إليه عند الطلب ويكتب الشيفرة لاستخدامه.

![تطبيق العرض التوضيحي لـ Helm يعرض الملفات في الدليل الحالي](/blog-images/helm-demo-app-list-files.png)


### عزل الشيفرة غير الموثوقة

أداة `execute` تشغّل أي شيفرة JavaScript يكتبها الـ LLM. لجعل ذلك آمنًا، يقوم العرض التوضيحي بعزلها باستخدام [SES (Secure ECMAScript)](https://github.com/endojs/endo/tree/master/packages/ses) داخل عملية فرعية (child process).

دالة SES `lockdown()` تجمّد جميع الكيانات الجوهرية في JavaScript — مثل `Object` و`Array` و`Promise` و`Function` وكل شيء آخر. تُشغَّل الشيفرة داخل `Compartment`، وهو نطاق عام (global scope) معزول لا يملك سوى شيئين بالضبط: وكيل `agent` ونسخة مبسَّطة من `console`. دوال مثل `fetch` و`require` و`import` و`process` و`fs` — كلها غير موجودة داخل الـ Compartment. الطريقة الوحيدة لفعل أي شيء مهم هي عبر وكيل الـ agent.

الـ `agent` داخل الـ sandbox ليس هو وكيل helm الحقيقي — بل هو `Proxy` تكراري يعترض الوصول إلى الخصائص واستدعاء الدوال. عندما تستدعي الشيفرة `agent.git.status()`، يرسل الـ proxy رسالة IPC إلى العملية الأب. تستدعي العملية الأب الدالة الحقيقية على وكيل helm الحقيقي، وتجري فحص الصلاحيات كاملًا، ثم ترسل النتيجة مرة أخرى. إذا كانت العملية مضبوطة على `"ask"`، تتوقف العملية الأب بانتظار موافقة المستخدم قبل الرد. إذا كانت `"deny"`، ينتقل الخطأ مرة أخرى عبر الـ IPC.

الشيفرة المعزولة لا تدرك أن أيًا من هذا يحدث. كل ما تراه هو أن جملة `await` خاصتها تُحلّ بقيمة ما. الطريقة الوحيدة للتفاعل مع العالم الخارجي هي عبر العمليات المحكومة بنظام الصلاحيات في helm.

### واجهة الأذونات

تحتوي واجهة الدردشة على شريط جانبي يسرد كل مهارة وعمليّة مسجَّلة، ولكلٍّ منها خيار allow/ask/deny. أي تغيير في الأذونات يسري بدءًا من الرسالة التالية.

![لوحة الأدوات مع عناصر تحكّم بالأذونات لكل عملية](/blog-images/helm-demo-app.png)

عندما يصل الـ LLM إلى عملية مضبوطة على `"ask"`، يقوم الخادم ببث طلب موافقة إلى الواجهة الأمامية. يعرض استدعاء الأداة شريطًا مضمَّنًا يحتوي على زري Allow وDeny. يعلّق الخادم التنفيذ على `Promise<boolean>` حتى ينقر المستخدم أحدهما.

![استدعاء أداة تنفيذ في انتظار موافقة المستخدم مع زري Allow وDeny](/blog-images/helm-demo-app-sandbox-feature.png)

إذا رفض المستخدم، ينتقل `PermissionDeniedError` عبر سلسلة الاستدعاءات إلى الأعلى، فيراه الـ LLM في نتيجة الأداة. عندها يمكنه أن يشرح لماذا يحتاج إلى الإذن، أو يحاول أسلوبًا مختلفًا، أو يستسلم.

## الإلهام

استُلهمت هذه البنية — تزويد الوكيل بأداة لتنفيذ الشيفرة بدلًا من عشرات الأدوات المنفردة — من وضع Cloudflare [code mode](https://blog.cloudflare.com/code-mode-mcp/) على خادم MCP لديهم، حيث خفّضوا استهلاك التوكنات بنسبة 99.9٪ عبر استبدال أكثر من 2,500 أداة لنقاط نهاية API بأداتي `search` و`execute`. [الفكرة المشابهة لـ Rhys Sullivan](https://x.com/RhysSullivan/status/2019819177473933404) هي ما بلور الأمر بالنسبة لي: إنّ الجمع بين تنفيذ الشيفرة، وإمكانية الاكتشاف، ونموذج صلاحيات شديد الدقة يعني أن الوكيل يمكنه فعل أي شيء تقريبًا، من دون أن يخرج عن السيطرة.

## جرِّبها

```bash
npm install @bgub/helm
```

المصدر متاح على [GitHub](https://github.com/bgub/helm). يوجد التطبيق التجريبي في `apps/demo`.
