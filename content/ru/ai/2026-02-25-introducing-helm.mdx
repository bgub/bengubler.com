---
title: "Знакомство с helm"
description: "Типизированный фреймворк на TypeScript для ИИ-агентов. Замените десятки инструментов двумя — search и execute — и запускайте код, который пишет LLM, в песочнице с тонко настраиваемыми правами доступа."
date: "2026-02-25"
tags: [ml/ai, open-source, frontend]
---

# Знакомьтесь: helm

helm — это типизированный фреймворк на TypeScript для AI‑агентов. Вместо запуска shell‑команд и парсинга строк агенты вызывают типизированные функции со структурированными входными и выходными данными:

```ts
import { createHelm, git, fs, grep } from "@bgub/helm";

const agent = createHelm({
  permissions: {
    "fs.read": "allow",
    "fs.write": "ask",
    "fs.remove": "deny",
    "git.status": "allow",
    "git.*": "ask",
  },
  onPermissionRequest: async (operation, args) => {
    return confirm(`Allow ${operation}?`);
  },
})
  .use(fs())
  .use(git())
  .use(grep());

const { staged, unstaged, branch } = await agent.git.status();
const { content } = await agent.fs.read("./package.json");
```

Вы регистрируете «skills» — группы связанных операций — с помощью паттерна builder. TypeScript выводит полный тип на каждом шаге. У каждой операции есть уровень доступа: `allow` (запускается сразу), `ask` (приостанавливается до подтверждения) или `deny` (выбрасывает `PermissionDeniedError`). Права доступа определяются по приоритету: точное совпадение → маска (wildcard) → умолчание, заданное автором skill → глобальное умолчание.

Helm поставляется со встроенными skills для задач, которые агенты выполняют каждый день: `fs`, `git`, `grep`, `edit`, `shell`, `http`. Вы можете определять собственные skills, и они автоматически получают типизацию, поиск и систему разрешений.


## Демо

Я сделал чат-бота, у которого агент располагает всего двумя инструментами: `search` и `execute`.

`search` выполняет поиск по ключевым словам среди всех зарегистрированных операций Helm — агент вызывает его, чтобы узнать, какие операции доступны, и изучить их сигнатуры:

```ts
agent.search("file read");
// → [{ qualifiedName: "fs.read",
//      description: "Прочитать файл и вернуть его содержимое в виде строки",
//      signature: "(path: string) => Promise<{ content: string }>", ... }]
```

`execute` принимает произвольный JavaScript‑код и выполняет его через API агента Helm. LLM пишет код вроде:

```js
const { staged, unstaged, branch } = await agent.git.status();
return { branch, staged: staged.length, unstaged: unstaged.length };
```

В контексте всего два инструмента, независимо от того, сколько навыков зарегистрировано. Агент по мере необходимости сам находит, что ему нужно, и пишет код для работы с этим.

![Демо‑приложение Helm, выводящее список файлов в текущем каталоге](/blog-images/helm-demo-app-list-files.png)


### Песочница для недоверенного кода

Инструмент `execute` запускает любой JavaScript, который пишет LLM. Чтобы сделать это безопасным, демо изолирует его в песочнице, используя [SES (Secure ECMAScript)](https://github.com/endojs/endo/tree/master/packages/ses) в дочернем процессе.

SES `lockdown()` замораживает все встроенные сущности JavaScript — `Object`, `Array`, `Promise`, `Function` и всё остальное. Код выполняется внутри `Compartment` — изолированной глобальной области видимости, у которой есть доступ ровно к двум вещам: прокси `agent` и урезанному `console`. `fetch`, `require`, `import`, `process`, `fs` — ничего этого в `Compartment` не существует. Единственный способ сделать что-то интересное — через прокси‑агент.

`agent` внутри песочницы — это не настоящий агент helm, а рекурсивный `Proxy`, который перехватывает доступ к свойствам и вызовы функций. Когда код вызывает `agent.git.status()`, прокси отправляет IPC‑сообщение в родительский процесс. Родитель вызывает настоящий метод на настоящем агенте helm, выполняет полную проверку прав доступа и отправляет результат обратно. Если операция настроена как `"ask"`, родитель приостанавливает выполнение и ждёт одобрения пользователя перед ответом. Если это `"deny"`, ошибка возвращается обратно через IPC.

Код в песочнице даже не подозревает, что всё это происходит. Он просто видит, что его `await` завершается с некоторым значением. Единственный способ взаимодействовать с внешним миром — через операции helm, защищённые системой разрешений.

### Интерфейс управления разрешениями

В интерфейсе чата есть боковая панель со списком всех зарегистрированных навыков и операций, у каждой — переключатель allow/ask/deny. Изменение разрешения начинает действовать со следующего сообщения.

![The tools panel with per-operation permission controls](/blog-images/helm-demo-app.png)

Когда LLM доходит до операции с флагом `"ask"`, сервер потоково отправляет запрос на одобрение на фронтенд. Вызов инструмента показывает встроенный баннер с кнопками Allow и Deny. Сервер блокируется на `Promise<boolean>`, пока пользователь не нажмёт одну из них.

![An execute tool call awaiting user approval with Allow and Deny buttons](/blog-images/helm-demo-app-sandbox-feature.png)

Если пользователь отклоняет запрос, `PermissionDeniedError` проходит по всей цепочке обратно, и LLM видит его в результате работы инструмента. Модель может объяснить, зачем ей нужно это разрешение, попробовать другой подход или сдаться.

## Вдохновение

На эту архитектуру — идею дать агенту один инструмент для выполнения кода вместо десятков отдельных инструментов — меня вдохновил режим [code mode](https://blog.cloudflare.com/code-mode-mcp/) от Cloudflare для их MCP-сервера, где им удалось сократить расход токенов на 99,9%, заменив более чем 2 500 инструментов для API-эндпоинтов на всего лишь `search` + `execute`. [Похожая идея Rhys Sullivan](https://x.com/RhysSullivan/status/2019819177473933404) окончательно всё для меня прояснила: сочетание выполнения кода, удобного обнаружения возможностей и детализированной модели прав доступа означает, что агент может делать почти всё, но не может выйти из-под контроля.

## Попробуйте сами

```bash
npm install @bgub/helm
```

Исходный код находится на [GitHub](https://github.com/bgub/helm). Демо‑приложение находится в `apps/demo`.
