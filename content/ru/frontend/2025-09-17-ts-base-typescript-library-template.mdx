---
title: "Представляю ts-base: современный шаблон библиотеки TypeScript"
description: "Сборка с tsdown, Vitest, release-please и Biome."
date: "2025-09-17T12:30:00-06:00"
tags: [frontend, open-source]
---

Восемь лет назад я выпустил свою первую open-source библиотеку на TypeScript — [Squirrelly](https://github.com/squirrellyjs/squirrelly) — в которой было всего два файла: `package.json` и `index.js`. Пять лет назад я выпустил [Eta](https://github.com/bgub/eta) с множеством новых возможностей, включая тестирование, линтинг, бандлинг и CI/CD.

Мне казалось, что это довольно крепкая рабочая среда, но времена меняются, а экосистема JavaScript развивается стремительно. Появились новые инструменты, лучшие практики эволюционировали, и сложность корректной публикации пакета в npm каким-то образом стала одновременно и ниже, и более подавляющей.

Достаточно взглянуть на эволюцию поля "exports" в `package.json`, если хотите головной боли. Или попробуйте подобрать правильную комбинацию конфигов TypeScript, бандлеров и CI‑воркфлоу, чтобы опубликовать библиотеку, которая безупречно работает в Node, Deno, Bun и браузерах. Удивительно сложно сделать это правильно.

Именно поэтому я создал [**ts-base**](https://github.com/bgub/ts-base) — современный стартовый шаблон для библиотек на TypeScript, который берёт на себя всю эту сложность. Он с чёткими мнениями, проверен боем и из коробки работает со всеми основными JavaScript‑рантаймами.

## Что такое ts-base?

ts-base — это шаблон библиотеки TypeScript, который использует современные инструменты и автоматизированные процессы. Вместо того чтобы начинать с нуля или копировать устаревший шаблон, вы получаете полноценную среду разработки с линтингом, тестированием, сборкой, выпуском и публикацией — всё уже настроено и готово к работе.

Шаблон основан на трёх ключевых принципах:

- **Сначала мультирантайм**: Бесшовно работает в Node, Deno, Bun и браузерах
- **Автоматизация вместо конфигурирования**: Минимум ручной настройки, максимум автоматизации
- **Современные инструменты**: Только ESM, актуальный TypeScript и тщательно подобранные зависимости

## Архитектура для нескольких рантаймов

Суть ts-base — его независимый от среды исполнения дизайн. Вместо попыток заставить один файл работать везде (и разбираться с головной болью совместимости) шаблон использует чёткое разделение:

```typescript
// src/internal.ts - Основная логика, без API специфичных для среды выполнения
export function add(a: number, b: number): number {
  return a + b;
}

export function greet(name: string, options = {}): string {
  const base = `Привет, ${name}`;
  return options.shout ? `${base.toUpperCase()}!` : `${base}.`;
}
```

```typescript
// src/index.ts - адаптер Node/Bun
export { add, greet } from "./internal";
import { randomBytes } from "node:crypto";

export function getSecureRandomId(): string {
  const timePart = Date.now().toString(36);
  const bytes = randomBytes(12).toString("base64url");
  return `${timePart}-${bytes}`;
}
```

```typescript
// src/browser.ts - Браузерный адаптер
export { add, greet } from "./internal";

export function getSecureRandomId(): string {
  const timePart = Date.now().toString(36);
  const array = new Uint8Array(12);
  crypto.getRandomValues(array);
  const rand = btoa(String.fromCharCode(...array))
    .replaceAll("+", "-")
    .replaceAll("/", "_")
    .replaceAll("=", "");
  return `${timePart}-${rand}`;
}
```

Это обеспечивает чистые импорты для каждого окружения выполнения:

```typescript
// Node/Bun
import { add, getSecureRandomId } from "@your-package/ts-base";

// Браузер (через бандлер)
import { add, getSecureRandomId } from "@your-package/ts-base/browser";

// Deno (прямой импорт TypeScript)
import {
  add,
  greet,
} from "https://jsr.io/@bgub/ts-base/<version>/src/index.ts";
```

Система сборки использует [tsdown](https://tsdown.dev/) для создания двух оптимизированных сборок: одной для среды Node и отдельной минифицированной сборки для браузеров, обе с картами исходников.


## Опыт разработчика

ts-base объединяет ваш инструментарий вокруг нескольких отличных решений:

**Biome** заменяет и ESLint, и Prettier одним быстрым инструментом. Никаких конфликтов конфигурации и несовместимых плагинов — только единообразное форматирование и линтинг «из коробки».

**Vitest** обеспечивает молниеносное тестирование со встроенными отчётами о покрытии и настраиваемыми порогами. Тесты запускаются параллельно, нативно поддерживают TypeScript и включают полезные возможности — моки и снапшоты.

**Size Limit** автоматически отслеживает размер вашего бандла. Он запускается в CI и оставляет комментарии в pull request, если изменения увеличивают размер бандла, помогая выявить излишний рост ещё до релиза.

Конфигурация TypeScript оптимизирована для современных бандлеров: настройки `moduleResolution: "bundler"` и `allowImportingTsExtensions: true` отлично работают с такими инструментами, как Vite, Rollup и esbuild.

## Автоматизированный конвейер CI/CD

Одно из главных преимуществ ts-base — полностью настроенная CI/CD. Каждый аспект контроля качества и публикации автоматизирован:

**Контроль качества**: Каждый pull request запускает линтинг, проверку типов, тесты и отчёт о покрытии. CI загружает данные о покрытии в Codecov и оставляет комментарии в PR с отчётами о влиянии на размер.

![Screenshot of CI/CD run](/blog-images/ci-run-screenshot.png)

**Управление релизами**: Вместо сложных конфигураций semantic-release ts-base использует Google Release Please. Когда коммиты попадают в main, Release Please автоматически открывает «Release PR», который обновляет версии, генерирует changelog и создаёт теги релизов.

**Автоматическая публикация**: Когда вы мёржите Release PR, GitHub Actions автоматически собирает и публикует пакет в npm и JSR с полной OIDC-происхождением и аттестацией безопасности.

**Conventional Commits**: Заголовки PR автоматически проверяются на соответствие формату conventional commits, обеспечивая единообразную генерацию changelog.

## Почему этот подход работает лучше

Большинство шаблонов библиотек TypeScript, которые я видел, либо слишком минималистичны (оставляя вам разбираться с CI, публикацией и поддержкой нескольких сред выполнения), либо чрезмерно усложнены десятками зависимостей. Я встречал шаблоны с пакетами вроде `@commitlint/cli`, `@commitlint/config-conventional`, `@semantic-release/changelog`, `@semantic-release/git`, `@semantic-release/github`, `@semantic-release/npm` и другими — и всё это только ради публикации через CI!

ts-base предлагает другой подход — всего 8 dev-зависимостей. Выбирая Release Please вместо semantic-release, Biome вместо ESLint+Prettier и Vitest вместо Jest, вы получаете более простый граф зависимостей, который легче поддерживать и который реже ломается.

Подход с автоматизацией означает меньше настроек и меньше точек отказа. Release Please в одном инструменте отвечает за повышение версии, генерацию changelog и создание релиза. Рабочие процессы GitHub Actions берут на себя всё остальное.

## Магия Release Please

![Screenshot of release-please PR](/blog-images/release-please-pr.png)

Release Please заслуживает особого внимания, потому что меняет подход к релизам. Вместо ручного повышения версий или настройки сложных пайплайнов semantic-release, Release Please работает так:

1. Вы мёрджите коммиты в `main`, используя conventional commits
2. Release Please автоматически открывает/обновляет Release PR с повышениями версий и записями в changelog
3. Когда готовы к релизу, просто смёрджите Release PR
4. GitHub Actions автоматически публикует в npm и JSR

Система поддерживает и предварительные релизы. Если вы выпускаете alpha- или beta-версию, она автоматически публикуется под тегом next в npm. Вы можете переопределять повышение версии, указав `Release-As: 2.0.0` в сообщениях коммитов, а также поддерживать несколько релизных веток (например, `2.x` и `3.x`), у каждой будет свой Release PR.

## Первые шаги

Настроить ts-base несложно:

1. **Клонируйте и адаптируйте**: Клонируйте репозиторий, удалите папку `.git` и обновите `package.json`, `jsr.json` и `.release-please-manifest.json`, указав данные вашего пакета.

2. **Займите имя пакета**: Установите версию `0.0.0` во всех конфигурационных файлах, затем локально выполните `npm publish`, чтобы занять имя вашего пакета в npm.

3. **Настройте публикацию**: В npm включите 2FA только для авторизации (не для публикации), затем добавьте ваш GitHub workflow как доверенного издателя. В JSR создайте пакет и добавьте репозиторий как доверенный источник.

![Скриншот настроек публикации в npm](/blog-images/npm-trusted-publisher.png)

4. **Настройте GitHub**: Запушьте в GitHub, добавьте `CODECOV_TOKEN` как секрет репозитория и настройте правила защиты веток.

5. **Начинайте разработку**: Добавьте код в `src/`, напишите тесты и запушьте коммиты. Release Please сделает остальное.

Рекомендую настроить GitHub так, чтобы был разрешён только squash merge, и использовать «pull request title and commit details» как сообщение коммита по умолчанию. Это помогает держать историю коммитов в порядке и обеспечивает соответствие conventional commits.

## Рекомендации и советы

**Настройки репозитория**: Включите защиту ветки `main` с обязательными проверками статуса. Отключите merge-коммиты, чтобы история оставалась линейной.

**Точки входа**: Используйте основной экспорт (`@your-package`) для Node/Bun, экспорт для браузера (`@your-package/browser`) для собранного кода под браузер и прямые импорты TypeScript для Deno.

**Настройка**: Если вам не нужны отдельные сборки для Node и браузера, удалите неиспользуемую конфигурацию. Шаблон рассчитан на то, чтобы его можно было урезать под ваши конкретные нужды.

**Стратегия тестирования**: Шаблон включает примеры тестирования как общего, так и платформенно-специфичного кода, включая мокирование браузерных API в тестовой среде Node.

## Подводим итоги

Публикация библиотеки на TypeScript не должна требовать учёной степени по настройке инструментов. ts-base предлагает современную, выверенную основу, которая берёт на себя всю сложность, чтобы вы могли сосредоточиться на создании отличного ПО.

Этот шаблон — результат восьми лет опыта поддержки проектов с открытым исходным кодом. Готовы попробовать? Загляните в [репозиторий ts-base](https://github.com/bgub/ts-base) и начинайте создавать свою следующую библиотеку.