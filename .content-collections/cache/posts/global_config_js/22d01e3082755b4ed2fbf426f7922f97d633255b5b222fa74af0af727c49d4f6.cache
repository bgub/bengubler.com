"var Component=(()=>{var g=Object.create;var r=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var u=Object.getPrototypeOf,m=Object.prototype.hasOwnProperty;var j=(i,e)=>()=>(e||i((e={exports:{}}).exports,e),e.exports),b=(i,e)=>{for(var o in e)r(i,o,{get:e[o],enumerable:!0})},c=(i,e,o,s)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let t of p(e))!m.call(i,t)&&t!==o&&r(i,t,{get:()=>e[t],enumerable:!(s=f(e,t))||s.enumerable});return i};var w=(i,e,o)=>(o=i!=null?g(u(i)):{},c(e||!i||!i.__esModule?r(o,\"default\",{value:i,enumerable:!0}):o,i)),x=i=>c(r({},\"__esModule\",{value:!0}),i);var a=j((v,l)=>{l.exports=_jsx_runtime});var y={};b(y,{default:()=>h});var n=w(a());function d(i){let e={a:\"a\",code:\"code\",em:\"em\",h2:\"h2\",p:\"p\",pre:\"pre\",...i.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"Modern web development involves working with multiple JS build tools and frameworks, each requiring their own configuration files. Managing these configuration files, such as \",(0,n.jsx)(e.code,{children:\".eslintrc\"}),\", \",(0,n.jsx)(e.code,{children:\"next.config.js\"}),\", and \",(0,n.jsx)(e.code,{children:\"tailwind.config.js\"}),\", can become cumbersome and time-consuming. In this blog post, I'll explore the idea of combining these configuration files into a single file called \",(0,n.jsx)(e.code,{children:\"global.config.js\"}),\", centralizing project configuration and reducing distractions.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Config files everywhere\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"As I'm writing this blog post, my project root contains an \",(0,n.jsx)(e.code,{children:\".eslintrc.json\"}),\", \",(0,n.jsx)(e.code,{children:\"next.config.js\"}),\", \",(0,n.jsx)(e.code,{children:\"postcss.config.js\"}),\", \",(0,n.jsx)(e.code,{children:\"tailwind.config.js\"}),\", and \",(0,n.jsx)(e.code,{children:\"tsconfig.json\"}),\". Although my configuration is pretty out-of-the-box and each file is less than 30 lines, those files take up valuable space in my VSCode sidebar and distract from what's important: my source code.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"My case is far from exceptional. Some other projects use far more configuration files. Imagine how cluttered a project can get when you add a \",(0,n.jsx)(e.code,{children:\".babelrc\"}),\", \",(0,n.jsx)(e.code,{children:\"prettier.config.js\"}),\", \",(0,n.jsx)(e.code,{children:\"jest.config.js\"}),\", \",(0,n.jsx)(e.code,{children:\"cypress.json\"}),\", etc.\"]}),`\n`,(0,n.jsxs)(e.h2,{children:[\"The solution: \",(0,n.jsx)(e.code,{children:\"global.config.js\"})]}),`\n`,(0,n.jsxs)(e.p,{children:[\"I'd like to propose a simple solution: consolidating configuration files in a file called \",(0,n.jsx)(e.code,{children:\"global.config.js\"}),\". The configuration for each tool would be stored in the exported object, under a key with the name of the npm package.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Projects should still allow usage of individual configuration files for cases when configuration is large and complex (e.g. \",(0,n.jsx)(e.code,{children:\"tsconfig.json\"}),\"), but should first scan to see if a \",(0,n.jsx)(e.code,{children:\"global.config.js\"}),\" exists and configuration for their tool is present.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Here's what a simple \",(0,n.jsx)(e.code,{children:\"global.config.js\"}),\" might look like:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`module.exports = {\n  eslint: {\n    extends: [\"next/core-web-vitals\"]\n  },\n  postcss: {\n    plugins: {\n      tailwindcss: {},\n      autoprefixer: {}\n    }\n  },\n  tailwindcss: {\n    content: [\"./src/pages/**/*.{js,ts,jsx,tsx,mdx}\"],\n    theme: {\n      extend: {\n        backgroundImage: {\n          \"gradient-radial\": \"radial-gradient(var(--tw-gradient-stops))\"\n        }\n      }\n    },\n    plugins: [require(\"@tailwindcss/typography\")]\n  }\n}\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"But what about types?\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Type completion can be easily enabled for \",(0,n.jsx)(e.code,{children:\"global.config.js\"}),\" by adding type definitions in comments, like Tailwind and NextJS already do in their config files.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`module.exports = {\n  // ...\n\n  /** @type {import('tailwindcss').Config} */\n  tailwindcss: {\n    content: [\"./src/pages/**/*.{js,ts,jsx,tsx,mdx}\"],\n    theme: {\n      extend: {\n        backgroundImage: {\n          \"gradient-radial\": \"radial-gradient(var(--tw-gradient-stops))\"\n        }\n      }\n    },\n    plugins: [require(\"@tailwindcss/typography\")]\n  }\n}\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"Next steps\"}),`\n`,(0,n.jsx)(e.p,{children:\"If you like this idea, submit a PR to your favorite build tool! If you don't, let me know why on Twitter. Or don't and just keep going about your life.\"}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsxs)(e.em,{children:[\"If you liked the article, don't forget to share it and follow me at \",(0,n.jsx)(e.a,{href:\"https://twitter.com/nebrelbug\",children:\"@nebrelbug\"}),\" on Twitter.\"]})})]})}function h(i={}){let{wrapper:e}=i.components||{};return e?(0,n.jsx)(e,{...i,children:(0,n.jsx)(d,{...i})}):d(i)}return x(y);})();\n;return Component;"