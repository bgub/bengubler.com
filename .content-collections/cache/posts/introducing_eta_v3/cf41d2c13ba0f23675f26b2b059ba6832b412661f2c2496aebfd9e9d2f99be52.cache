"var Component=(()=>{var u=Object.create;var a=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var f=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var w=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),b=(t,e)=>{for(var i in e)a(t,i,{get:e[i],enumerable:!0})},s=(t,e,i,o)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of m(e))!g.call(t,r)&&r!==i&&a(t,r,{get:()=>e[r],enumerable:!(o=p(e,r))||o.enumerable});return t};var y=(t,e,i)=>(i=t!=null?u(f(t)):{},s(e||!t||!t.__esModule?a(i,\"default\",{value:t,enumerable:!0}):i,t)),v=t=>s(a({},\"__esModule\",{value:!0}),t);var l=w((j,d)=>{d.exports=_jsx_runtime});var E={};b(E,{default:()=>h});var n=y(l());function c(t){let e={a:\"a\",code:\"code\",em:\"em\",h2:\"h2\",li:\"li\",p:\"p\",pre:\"pre\",ul:\"ul\",...t.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"Background\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Today, Eta is my most popular and widely used open-source project. But when I first published it 3 years ago, it wasn't one of my primary focuses. In fact, I created Eta as a slimmed-down variation of \",(0,n.jsx)(e.a,{href:\"https://squirrelly.js.org\",children:\"Squirrelly\"}),\", a more complex template engine with features like helpers and filters.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"As time passed, I realized that for most projects, an embedded template engine was actually a better fit than something more complex. Projects which needed complex or client-side HTML processing typically used a framework like React or Vue. Eta's performance and low bundle size, meanwhile, made it a great fit for projects which needed fast processing, low memory usage, or to handle non-XML languages.\"}),`\n`,(0,n.jsx)(e.p,{children:\"At the same time, Eta had become increasingly popular thanks to its speed, Deno support, and syntactic advantages over EJS. Given those factors, I decided to make Eta my main focus. I spent time writing tutorials, fixing issues, and polishing documentation.\"}),`\n`,(0,n.jsx)(e.p,{children:\"After several years and some time spent away from programming as a missionary, I finally had time to work on Eta again. I decided to make some big changes to the project, including the build system, API, and documentation.\"}),`\n`,(0,n.jsx)(e.h2,{children:\"Build System Updates\"}),`\n`,(0,n.jsx)(e.p,{children:\"Despite Eta's advantages and features, it had some big problems. One such problem was the build system. Complex and unwieldy, it was difficult to maintain and update. I dealt with complex configuration files and the necessity of transpiling a version specifically for Deno.\"}),`\n`,(0,n.jsx)(e.p,{children:\"Changes in version 3:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Using \",(0,n.jsx)(e.a,{href:\"https://github.com/developit/microbundle\",children:\"microbundle\"}),\" to bundle the library helped me avoid the need for complex configuration files.\"]}),`\n`,(0,n.jsx)(e.li,{children:\"Using GitHub Actions to run tests and collect coverage allowed me to consolidate the services I used.\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"By setting \",(0,n.jsx)(e.code,{children:\"allowImportingTsExtensions: true\"}),\" in \",(0,n.jsx)(e.code,{children:\"tsconfig.json\"}),\", I was able to avoid using \",(0,n.jsx)(e.a,{href:\"https://github.com/garronej/denoify\",children:\"Denoify\"}),\" for a separate Deno build.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"API Changes\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Another problem was the API. Simple methods like \",(0,n.jsx)(e.code,{children:\"eta.render()\"}),\" had many function overloads, making types difficult to infer and usage unintuitive. A custom configuration object could be passed in when calling user-exposed functions like \",(0,n.jsx)(e.code,{children:\"render\"}),\", \",(0,n.jsx)(e.code,{children:\"parse\"}),\", and \",(0,n.jsx)(e.code,{children:\"compile\"}),\". In practice, that meant the user-provided configuration had to be merged with the default configuration every time any of those functions was called.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Changes in version 3:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"There's only one export, a named class called \",(0,n.jsx)(e.code,{children:\"Eta\"}),\". This class has a single constructor, which processes a configuration object and generates template caches at instantiation time.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"The \",(0,n.jsx)(e.code,{children:\"render()\"}),\" and \",(0,n.jsx)(e.code,{children:\"renderAsync()\"}),\" functions now have a single function signature.\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"In Eta v2, \",(0,n.jsx)(e.code,{children:\"render()\"}),\" and \",(0,n.jsx)(e.code,{children:\"renderAsync()\"}),\" could be used to render either named templates or template strings. Eta v3 introduces two new functions to render template strings: \",(0,n.jsx)(e.code,{children:\"renderString()\"}),\" and \",(0,n.jsx)(e.code,{children:\"renderStringAsync()\"}),\".\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"The \",(0,n.jsx)(e.code,{children:\"readFile()\"}),\" and \",(0,n.jsx)(e.code,{children:\"resolvePath()\"}),\" functions, which Eta uses internally, can be overridden as class methods by the user.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Internal variables and methods inside each compiled template are stored in the \",(0,n.jsx)(e.code,{children:\"__eta\"}),\" object, rather than across several variables including \",(0,n.jsx)(e.code,{children:\"__res\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Rather than allowing users to specify one \",(0,n.jsx)(e.code,{children:\"root\"}),\" directory and multiple \",(0,n.jsx)(e.code,{children:\"views\"}),\" directories, users may just specify a single \",(0,n.jsx)(e.code,{children:\"views\"}),\" directory. This directory is used as the root directory for all template resolution. All template files must be inside this directory or a subdirectory of it, improving template security and reducing expensive file-lookup operations.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Developer Experience Changes\"}),`\n`,(0,n.jsx)(e.p,{children:\"One of the biggest changes in Eta v3 was the addition of detailed runtime errors (inspired by EJS). Consider a template like the following, which will throw because of an undefined variable:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-eta\",children:`Template header\n<%= undefinedVariable %>\nLorem Ipsum\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"Eta v2 would throw an error with some generic info, but it wasn't incredibly helpful. In contrast, Eta v3 throws a detailed error with the template name, line number, and error message:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{children:`EtaError [ReferenceError]: .../my-dir/templates/runtime-error.eta:2\n    1| Template header\n >> 2| <%= undefinedVariable %>\n    3| Lorem Ipsum\n\nundefinedVariable is not defined\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"Documentation Changes\"}),`\n`,(0,n.jsx)(e.p,{children:\"The documentation for Eta v2 was extensive but very difficult to navigate. Information about the project was split over 40+ (!) documentation pages, found in multiple folders spread across 3 different website sections.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The documentation for Eta v3 takes up 9 pages, all found in the same part of the website (\",(0,n.jsx)(e.a,{href:\"https://eta.js.org\",children:\"eta.js.org\"}),\"). Topics like template syntax and API overview are covered in a single page, rather than being split across multiple pages.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"The Future of Eta\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"I'm proud of the changes included in Eta v3, and of the project as a whole. Much thanks to those who contributed to the project through PRs, issues, and suggestions. Additional thanks to projects like \",(0,n.jsx)(e.a,{href:\"https://github.com/mde/ejs\",children:\"ejs\"}),\", from which Eta continues to draw inspiration.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"I see Eta as mostly feature-complete at this point, though I'll continue to fix bugs and add some small features. I'd encourage current users of the library to upgrade to v3, and I hope new users will find Eta to be a great fit for their projects.\"}),`\n`,(0,n.jsx)(e.h2,{children:\"Links\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://github.com/eta-dev/eta\",children:\"Eta on GitHub\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://www.npmjs.com/package/eta\",children:\"Eta on npm\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://eta.js.org\",children:\"Eta website and docs\"})}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsxs)(e.em,{children:[\"If you liked the article, don't forget to share it and follow me at \",(0,n.jsx)(e.a,{href:\"https://twitter.com/nebrelbug\",children:\"@nebrelbug\"}),\" on Twitter.\"]})})]})}function h(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,{...t,children:(0,n.jsx)(c,{...t})}):c(t)}return v(E);})();\n;return Component;"