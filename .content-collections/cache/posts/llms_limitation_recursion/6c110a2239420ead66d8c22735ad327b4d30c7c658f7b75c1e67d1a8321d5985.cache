"var Component=(()=>{var u=Object.create;var o=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var f=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var b=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),w=(t,e)=>{for(var i in e)o(t,i,{get:e[i],enumerable:!0})},s=(t,e,i,a)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of p(e))!g.call(t,r)&&r!==i&&o(t,r,{get:()=>e[r],enumerable:!(a=m(e,r))||a.enumerable});return t};var y=(t,e,i)=>(i=t!=null?u(f(t)):{},s(e||!t||!t.__esModule?o(i,\"default\",{value:t,enumerable:!0}):i,t)),T=t=>s(o({},\"__esModule\",{value:!0}),t);var l=b((k,h)=>{h.exports=_jsx_runtime});var v={};w(v,{default:()=>d});var n=y(l());function c(t){let e={a:\"a\",em:\"em\",h2:\"h2\",p:\"p\",strong:\"strong\",...t.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"The Problem\"}),`\n`,(0,n.jsx)(e.p,{children:\"LLMs have tremendous potential in many areas, but most contemporary models have one inherent limitation: they're solely feed-forward in structure. This means that data flows linearly from input to output, with no recursion or backtracking. This enables incredibly fast and efficient training using gradient descent and back-propagation. Computations can be done in parallel using matrix multiplication.\"}),`\n`,(0,n.jsx)(e.p,{children:\"Unfortunately, their lack of recursion makes some types of mathematical operations impossible. Consider exponentiation. ChatGPT can handle simple exponent problems, but when asked what X^Y is for high values of X or Y, it becomes inaccurate.\"}),`\n`,(0,n.jsx)(e.p,{children:`Though exponential operations can be broken down into a linear sequence, it's impossible for a finite, feed-forward neural net to handle any possible recursive operation (i.e., X^Y with any possible value for Y). The amount of recursion an LLM can \"simulate\" is limited by the number of its parameters and layers.`}),`\n`,(0,n.jsx)(e.h2,{children:\"Summary\"}),`\n`,(0,n.jsx)(e.p,{children:\"Lack of recursion is an inherent design limitation in current GPT-style LLMs which prevents them from being able to perform complicated math operations. The fact is, though, that doesn't matter in most use cases for LLMs! They're still powerful and helpful in a wide variety of circumstances.\"}),`\n`,(0,n.jsx)(e.h2,{children:\"Fun Stuff\"}),`\n`,(0,n.jsx)(e.p,{children:\"There's still a lot of work to be done in understanding the behavior of trained large language models. Here's something fascinating I found while writing this article:\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"When I asked ChatGPT what 7^15 equals, it gave the answer \",(0,n.jsx)(e.strong,{children:\"170,859,375\"}),\". The correct answer is \",(0,n.jsx)(e.strong,{children:\"4,747,561,509,943\"}),\".\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Though the answer is obviously incorrect, \",(0,n.jsx)(e.strong,{children:\"170,859,375\"}),\" has a unique property: it factors into \",(0,n.jsx)(e.strong,{children:\"(3^7)*(5^7)\"}),\". The model seems to have converted \",(0,n.jsx)(e.strong,{children:\"A^(B*C)\"}),\" into \",(0,n.jsx)(e.strong,{children:\"(B^A)*(C^A)\"}),\" under the hood. I'd be interested to learn why this happens!\"]}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsxs)(e.em,{children:[\"If you liked the article, don't forget to share it and follow me at \",(0,n.jsx)(e.a,{href:\"https://twitter.com/nebrelbug\",children:\"@nebrelbug\"}),\" on Twitter.\"]})})]})}function d(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,{...t,children:(0,n.jsx)(c,{...t})}):c(t)}return T(v);})();\n;return Component;"