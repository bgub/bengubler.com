"var Component=(()=>{var m=Object.create;var i=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var w=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),b=(t,e)=>{for(var a in e)i(t,a,{get:e[a],enumerable:!0})},h=(t,e,a,o)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of p(e))!f.call(t,r)&&r!==a&&i(t,r,{get:()=>e[r],enumerable:!(o=u(e,r))||o.enumerable});return t};var y=(t,e,a)=>(a=t!=null?m(g(t)):{},h(e||!t||!t.__esModule?i(a,\"default\",{value:t,enumerable:!0}):a,t)),k=t=>h(i({},\"__esModule\",{value:!0}),t);var l=w((D,c)=>{c.exports=_jsx_runtime});var v={};b(v,{default:()=>d});var n=y(l());function s(t){let e={a:\"a\",code:\"code\",em:\"em\",h2:\"h2\",p:\"p\",pre:\"pre\",...t.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.p,{children:(0,n.jsxs)(e.em,{children:[\"This is part 1 of a 2-part series. \",(0,n.jsx)(e.a,{href:\"./enroot-on-slurm-for-distributed-ml-part-2\",children:\"Part 2\"}),\" is available here.\"]})}),`\n`,(0,n.jsxs)(e.p,{children:[\"In the lab where I work, we have access to a High Performance Computing (HPC) environment that uses the \",(0,n.jsx)(e.a,{href:\"https://slurm.schedmd.com/documentation.html\",children:\"Slurm Workload Manager\"}),\". Our HPC runs RHEL (Red Hat Enterprise Linux) 7, and individual users have significantly restricted permissions. We don't have \",(0,n.jsx)(e.code,{children:\"sudo\"}),\" access and can't access the internet from the compute nodes.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"In fact, the process of loading packages and updating drivers from inside a compute node is so difficult that it makes distributed training using modern software incredibly complicated. Luckily, there's a solution: containerization.\"}),`\n`,(0,n.jsx)(e.p,{children:\"We'll use Docker to build an image on our local machine that contains all of the packages we need. Then we can transfer that image to the HPC, and use it to run our training script.\"}),`\n`,(0,n.jsx)(e.h2,{children:\"Step 1: Build a Docker Image Locally\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"I already wrote about \",(0,n.jsx)(e.a,{href:\"./ultimate-ml-dockerfile\",children:\"the Docker setup I use for machine learning\"}),\", so I won't repeat myself here. The important thing is that you have a tagged Docker image with the packages you need to run your training script. Mine uses Ubuntu 20.04 and CUDA 11.8.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Step 2: Squash and Transfer the Image\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Install \",(0,n.jsx)(e.a,{href:\"https://github.com/NVIDIA/enroot\",children:\"Enroot\"}),\", then run the following command to turn your Docker image into a squashfs file:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-bash\",children:`enroot import dockerd://<image-name>\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"This will create a file called \",(0,n.jsx)(e.code,{children:\"<image-name>.sqsh\"}),\" in your current directory. Transfer this file to the HPC using \",(0,n.jsx)(e.code,{children:\"scp\"}),\".\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Step 3: Load the Image on the HPC\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Enter a compute node using \",(0,n.jsx)(e.code,{children:\"salloc --nodes=1 --gpus=8 --qos=<qos> --mem=2000G --time=72:00:00 --ntasks=1 --cpus-per-task=128\"}),\".\"]}),`\n`,(0,n.jsx)(e.p,{children:\"First we need to load the Enroot module:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-bash\",children:`module load jq zstd pigz parallel libnvidia-container enroot\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"On the HPC, create the image using the following command:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-bash\",children:`enroot create --name image-name /path/to/image-name.sqsh\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"Then run it:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-bash\",children:`enroot start --mount /local/file/path:/image/file/path \\\\\n             --rw image-name bash\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"This will open up an interactive shell inside the container. Don't forget the \",(0,n.jsx)(e.code,{children:\"--rw\"}),\" flag, which makes the root filesystem writable. You can add as many \",(0,n.jsx)(e.code,{children:\"--mount\"}),\" flags as you need to mount files and directories from the host machine.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"If you want to pass through environment variables, you can use the \",(0,n.jsx)(e.code,{children:\"--env\"}),\" flag along with the name of the environment variable on the host machine. For example, \",(0,n.jsx)(e.code,{children:\"--env SLURM_NODEID\"}),\" will pass through the \",(0,n.jsx)(e.code,{children:\"SLURM_NODEID\"}),\" environment variable.\"]}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsxs)(e.em,{children:[\"If you liked the article, don't forget to share it and follow me at \",(0,n.jsx)(e.a,{href:\"https://twitter.com/nebrelbug\",children:\"@nebrelbug\"}),\" on Twitter.\"]})})]})}function d(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,{...t,children:(0,n.jsx)(s,{...t})}):s(t)}return k(v);})();\n;return Component;"